"=====
"==general
"=====
"--load plugins.  load first so we can override
source ~/.vim/plugins.vim

"--Use Vim advanced settings
set nocompatible


"=====
"==styles
"=====

colorscheme koehler
highlight Normal ctermfg=lightgreen guifg=#b0ffb3

"--use our colorscheme if MacVim
if has('gui_macvim')
	let macvim_skip_colorscheme=1
endif

"--syntax highlighting
syntax on

"--show line numbers
set number

"--highlight current line
set cursorline
highlight CursorLine guibg=#444444
highlight CursorLineNr ctermfg=black ctermbg=green guifg=black guibg=green

"--Show the cursor position all the time
set ruler

"--make it noticeable which mode I'm in
augroup TJMInsertBGStyle
	autocmd!
	autocmd InsertEnter * hi Normal term=reverse	guibg=#002200
	autocmd InsertLeave * hi Normal term=NONE	guibg=black
	autocmd InsertEnter * hi LineNr term=reverse ctermfg=cyan guifg=cyan guibg=#003300
	autocmd InsertLeave * hi LineNr term=NONE ctermfg=yellow guifg=yellow guibg=#001100
augroup end

"--show whitespace
if has('patch-7.4.710')
	set listchars=conceal:?,eol:¬,extends:…,nbsp:␣,precedes:…,space:·,tab:»\ ,trail:•
else
	"-# older vim doesn't support `space`
	set listchars=conceal:?,eol:¬,extends:…,nbsp:␣,precedes:…,tab:»\ ,trail:•
endif
set list
highlight NonText ctermfg=darkGray guifg=gray43
highlight SpecialKey ctermfg=darkGray guifg=gray43

"--wider width for wide characters
if has('gui_macvim')
	"-# doesn't seem to work in mac CLI version, not sure for others.  may need better `has()`
	"-# not helping most wide characters. Add double wides as needed
	"-# need listchars to be single width for ambiwidth
	call setcellwidths([
	\	str2list('…') + str2list('…') + [1],
	\	str2list('·') + str2list('·') + [1],
	\	str2list('•') + str2list('•') + [1]
	\])
	set ambiwidth=double
endif

"--vcs
highlight GitGutterAdd ctermfg=green guifg=green
highlight GitGutterChange ctermfg=yellow guifg=yellow
highlight GitGutterDelete ctermfg=red guifg=red

"--show colors
command! TMShowColors tabnew | so $VIMRUNTIME/syntax/hitest.vim

"==languagues
"--less
augroup TJMLessLang
	autocmd!
	autocmd BufNewFile,BufRead *.less set filetype=less
augroup END

"--twig
augroup twig
	au!
	au BufRead,BufNewFile *.twig set syntax=htmldjango
augroup end


"=====
"==ex
"=====
"--keep 50 lines of command history
set history=50

"--"menu" for file/multi completions
set wildignorecase
set wildmenu
set wildoptions=pum
"---ignore some directories for file matching
set wildignore+=*/node_modules/*
set wildignore+=vendor/*

"--show partial of current command
set showcmd


"=====
"==keyboard/ui
"=====
"--use OS clipboard
if has('mac')
	set clipboard=unnamed
else
	set clipboard=unnamedplus
endif

"--prevent jumping to start of line when moving cursor
set nostartofline

"--prevent auto-insert of line breaks
set textwidth=0
"---ensure this survives any ftplugins
augroup TJMTextWidth
	autocmd!
	autocmd BufEnter * setlocal textwidth=0
augroup END

"--show matching braces
set showmatch

"--shift key plus motion selects in visual mode
set keymodel=startsel

"--make backspace key work
set backspace=eol,indent,start

"--delete keys delete in visual mode
xnoremap <bs> "dd
xnoremap <del> "dd

"--quicker ex mode access
noremap ; :
noremap <f2>; ;

"--emacs beginning / end keys
cnoremap <c-a> <home>
cnoremap <f2>a <c-a>
inoremap <c-a> <home>
inoremap <f2>a <c-a>
inoremap <c-e> <end>
inoremap <f2>e <c-e>

"--text indent
nnoremap <tab> >>
xnoremap <tab> >gv
nnoremap <s-tab> <<
xnoremap <s-tab> <gv
"---improve standard indent in visual mode
xnoremap < <gv
xnoremap > >gv

"--search for selection in visual mode
"-@ https://vi.stackexchange.com/a/6209
xnoremap / :<c-u>let @/=@"<cr>gvy:let [@/,@"]=[@",@/]<cr>/\V<c-r>=substitute(escape(@/,'/\'),'\n','\\n','g')<cr><cr>

"--set number of undo's remembered
set undolevels=100

"==autocomplete
if exists("+omnifunc")
	set completeopt+=menuone,noinsert,noselect
	"--disable error when no matches found
	set shortmess+=c
	"--auto popup when three word characters in a row entered
	augroup TJMAutopleteOnIns
		autocmd!
		autocmd InsertCharPre * call TMAutopleteOnIns()
	augroup END
	fun! TMAutopleteOnIns()
		if len(&omnifunc) != 0
			\ && v:char =~ '\w'
			\ && getline('.')[col('.') - 3] =~ '\w'
			\ && getline('.')[col('.') - 2] =~ '\w'
			\ && getline('.')[col('.') - 1] !~ '\w'
			call feedkeys("\<C-x>\<C-o>", 'n')
		endif
	endfun
	"--close func def preview when ')' called to finish function call
	"-! not useful in all languages, but others would be much more complicated
	inoremap <expr> ) TMClosePreviewDone()
	fun! TMClosePreviewDone()
		for w in range(1, winnr('$'))
			if getwinvar(w, "&pvw") == 1
				call feedkeys("\<esc>:pclose\<CR>i\<right>", 'n')
			endif
		endfor
		return ")"
	endfun
	"--generic autocomplete
	"-! this only sort of works, not in all file types, not for all words, can be slow
	set omnifunc=syntaxcomplete#Complete
	"--hide line numbers in preview window
	augroup TJMHidePreviewLN
		autocmd!
		autocmd WinEnter * call TMHidePreviewLN()
	augroup END
	fun! TMHidePreviewLN()
		if &pvw
			setlocal nonumber
		endif
	endfun
	"--tab to select first / current item
	inoremap <expr> <Tab> pumvisible() ? (complete_info()['selected'] == -1 ? "\<C-n>" : "\<C-y>") : "\<Tab>"
endif

"==buffers
"--allow hiding / switching away from modified buffers
set hidden

"==comments
"--disable filetype based auto-wrap of comments
set formatoptions-=c
"--disable filetype based auto-comment
set formatoptions-=o formatoptions-=r
"--ensure these survive any ftplugins
augroup TJMCommentFormatOpts
	autocmd!
	autocmd BufEnter * setlocal formatoptions-=c
	autocmd BufEnter * setlocal formatoptions-=o formatoptions-=r
augroup END

"==gui
"--support mouse in all modes
set mouse=a

"--nicer scrolling for large wrapped lines
set smoothscroll

"==indent
"--auto indent
set ai
"--Don't expand tabs to spaces
set noexpandtab
"--generic auto indent only
filetype indent off
"--detects filetype, loads appropriate options and indentation rules
filetype plugin indent on
"--Number of spaces that a <Tab> in the file counts for
set softtabstop=4
set shiftwidth=4
set tabstop=4

"==leader
"--use space as leader key
map <space> <leader>
"--leader key in other modes
"-# must not be `nore` to allow leader key to work, except 'c'
"-! trying various options
imap <a-space> <c-o><leader>
map <a-space> <leader>
"cnoremap <f1> <esc><leader>
imap <f1> <c-o><leader>
inoremap <f2><f1> <help>
map <f1> <leader>
noremap <f2><f1> <help>
noremap <leader><f1> <help>
"--window switch
nnoremap <Space><Space> <c-w><c-w>
"--select all
nnoremap <leader>a ggVG
"--toggle buffers
nnoremap <leader>b <C-^>
nnoremap <leader>B :buffers<cr>:b
nnoremap <s-space>B :buffers<cr>:b
"--duplicate line / selection
nnoremap <leader>d :copy.<cr>
xnoremap <leader>d y`]p
"--file sidebar
nnoremap <leader>f :TMexplore<cr>
nnoremap <leader>F :TMexplore<space>
nnoremap <s-space>F :TMexplore<space>
"--git (fugitive plugin)
nnoremap <leader>g :tab G<cr>
"--git command line
nnoremap <leader>G :!git<space>
"--help
nnoremap <leader>h :tab help<space>
nnoremap <leader>H :tab help<cr>
"--open
nnoremap <leader>o :tab drop **/
"--quit
noremap <leader>q :<c-u>qa<CR>
"--reveal in file browser (mac only)
if has('mac')
	nnoremap <silent> <leader>r :silent !open -R % &<cr>:redraw!<cr>
endif
"--save
noremap <leader>s :update<cr>
noremap <leader>ss :update<cr>
"--spell check
noremap <leader>sc :set spell!<CR>
"--open terminal
nnoremap <leader>! :!
nnoremap <leader>t :!
nnoremap <leader>T :tab term<cr>
"--window close
noremap <leader>w :<c-u>close<CR>
"--tab close
fun! TMCloseBuffer()
	"--for help, need close unless last window
	if &ft == 'help' && winnr() != winnr('$')
		close
	"--otherwise, delete buffer unless last netrw
	elseif &ft !=# 'netrw' || len(getbufinfo({'buflisted':1})) > 1 || tabpagenr('$') > 1
		let origTab = tabpagenr()
		bdelete
		"--special handling of no name buffer when it's open with netrw as only other tab
		if expand('%') == '' && tabpagenr() > 1 && origTab == tabpagenr()
			let origBuffer = bufnr()
			close
			execute 'bdelete ' .. origBuffer
		endif
	endif
	if &ft !=# 'netrw' && expand('%') == '' && len(getbufinfo({'buflisted':1})) <= 1 && tabpagenr('$') <= 1
		Explore
		"--prevent empty files being added to buffer list
		for buf in filter(range(1, bufnr('$')), 'buflisted(v:val) && empty(bufname(v:val)) && bufwinnr(v:val) < 0 && (getbufline(v:val, 1, "$") == [""])')
			execute 'bdelete' buf
		endfor
	endif
endfun
noremap <leader>x :call TMCloseBuffer()<cr>
noremap <leader>X :if confirm('Are you sure you want to close without saving?', "&Yes\n&No", 1) == 1 <bar> q! <bar> endif<cr>
"--yank all
noremap <leader>y :%y+<cr>
"--reload vimrc
nmap <leader>< :so ~/.vimrc<cr>:echo 'reloaded vimrc'<cr>
"--edit vimrc
nmap <leader>, :e ~/.vimrc<cr>
"--command mode
noremap <leader>; :
noremap <leader>: :
"--surround text with parens
"-! visual mode version should either leave selection selected or move to end of selection when done
nnoremap <expr> <leader>( 'i' . (col(".") == col("$") - 1 ? '<right>' : '') . '()<esc>i'
xnoremap <leader>( :keeppatterns lockmarks s/\%V\_.*\%V/(&)/<cr>
"--surround text with block
nnoremap <expr> <leader>[ 'i' . (col(".") == col("$") - 1 ? '<right>' : '') . '[]<esc>i'
xnoremap <leader>[ :keeppatterns lockmarks s/\%V\_.*\%V/[&]/<cr>
"--surround text with curly braces
nnoremap <expr> <leader>{ 'i' . (col(".") == col("$") - 1 ? '<right>' : '') . '{}<esc>i'
xnoremap <leader>{ :keeppatterns lockmarks s/\%V\_.*\%V/{&}/<cr>
"--surround text with single quotes
nnoremap <expr> <leader>' 'i' . (col(".") == col("$") - 1 ? '<right>' : '') . '\'\'<esc>i'
xnoremap <leader>' :keeppatterns lockmarks s/\%V\_.*\%V/'&'/<cr>
"--surround text with double quotes
nnoremap <expr> <leader>" 'i' . (col(".") == col("$") - 1 ? '<right>' : '') . '""<esc>i'
xnoremap <leader>" :keeppatterns lockmarks s/\%V\_.*\%V/"&"/<cr>
"--restore ; (movement repeat)
noremap <Leader>. ;

"==search
"--highlight search terms
set hlsearch
"--ignore case in search
set ignorecase
"--display search matches while typing
set incsearch
"--show found count of search results
set shortmess-=S
"--search wraps around
set wrapscan

"==spell check
set spelllang=en

"==statusline
"-# intersting colors: #Cursor# #CursorColumn# #DiffAdd# #GitGutterAddIntraLine# #Pmenu#
set laststatus=2
set statusline=%#CursorColumn#\ %02.n\ %{%TJMStatusLine()%}%=%#CursorColumn#\ %-6.(%l/%L,%c%V%)\ %*
fun! TJMStatusLine()
	let l:isCurrent = g:actual_curwin == win_getid(winnr())
	let l:sl = '%#' . (l:isCurrent ? 'Cursor' : 'DiffAdd') . '# '
	if &ft == 'help'
		let l:sl .= '%Y %* %f'
	elseif &ft == 'netrw'
		let l:sl .= 'DIR %* %<' . substitute(getcwd(), '^' . $HOME, '~', 'i')
	elseif &ft == 'fugitive'
		let l:sl .= 'GIT %* %<' . substitute(getcwd(), '^' . $HOME, '~', 'i')
	else
		let l:sl .= (l:isCurrent ? toupper(mode()) : "-") . '%M %* '
		let l:sl .= '%<' . substitute(expand('%f'), '^' . getcwd() . '/\?', '', 'i') . ' %y%w%q%r'
	endif
	return l:sl
endfun
"--standard colors
highlight! link StatusLine DiffAdd
highlight! link StatusLineNC Pmenu

"==tabs
"--move tabs
"-@ https://stackoverflow.com/a/40919415/1139122
if has('gui_macvim')
	noremap <A-D-S-Left> :-tabmove<CR>
	inoremap <A-D-S-Left> <esc>:-tabmove<CR>i
	noremap <A-D-S-Right> :+tabmove<CR>
	inoremap <A-D-S-Right> <esc>:+tabmove<CR>i
endif

"--switch tabs via index
"-@ https://superuser.com/questions/382060/shortcut-to-switch-tabs-in-macvim
if has('gui_macvim')
	let i = 1
	while i <= 8
		exe 'noremap <D-' . i . '> :tabn ' . i . '<CR>'
		exe 'inoremap <D-' . i . '> <esc>:tabn ' . i . '<CR>i'
		let i += 1
	endwhile
	unlet i
	noremap <D-9> :tablast<CR>
	inoremap <D-9> <esc>:tablast<CR>i
endif
let i = 1
while i <= 8
	exe 'noremap <leader>' . i . ' :tabn ' . i . '<CR>'
	let i += 1
endwhile
unlet i
noremap <leader>9 :tablast<CR>

"==text
"--move lines
"-@ http://vim.wikia.com/wiki/Moving_lines_up_or_down
if has('gui_macvim')
	nnoremap <A-C-Down> :m .+1<CR>==
	inoremap <A-C-Down> <esc>:m .+1<CR>==gi
	vnoremap <A-C-Down> :m '>+1<CR>gv=gv
	nnoremap <A-C-Up> :m .-2<CR>==
	inoremap <A-C-Up> <esc>:m .-2<CR>==gi
	vnoremap <A-C-Up> :m '<-2<CR>gv=gv
endif

"==wrap
"--don't wrap mid-word
set linebreak


"=====
"==file manager
"=====
"--hide instruction banner
let g:netrw_banner=0
"--hide swap files in list
let g:netrw_list_hide= '.*\.swp$'
"--show human readable sizes
let g:netrw_sizestyle='h'
"--ignore case for sort
let g:netrw_sort_options="i"
"--open files in new tab by default
let g:netrw_browse_split = 3
"--sidebar
if !exists('g:TMExploreWin')
	let g:TMExploreWin=0
endif
fun! TMExploreFn(fp = '')
	if !exists('g:TMExploreOn')
		let g:TMExploreOn=0
	endif
	if g:TMExploreOn != 0 && g:TMExploreWin != 0
		execute ':tabn ' . g:TMExploreOn
		if len(a:fp) != 0
			execute ':e ' . a:fp
			echo 'opening args'
		else
			echo 'no args: ' . a:0 . ',' . a:fp
		endif
	else
		execute ':0tabnew'
		execute ':e ' . (len(a:fp) > 0 ? a:fp : '.')
		echo 'opening new with args ' . a:0 . ',' . a:fp
		let g:TMExploreOn=tabpagenr()
		let g:TMExploreWin=win_getid()
	endif
endfun
command! -nargs=? -complete=dir TMexplore call TMExploreFn(<f-args>)
augroup TJMExploreListen
	autocmd!
	autocmd WinClosed * if expand('<amatch>') == g:TMExploreWin | let g:TMExploreWin = 0 | endif
augroup END
"---ensure proper `netrw_browse_split` setting
"fun! TMExploreBrowseSplitSet()
	"if !exists('t:TMExploreOn')
		"let t:TMExploreOn=0
	"endif
	"if t:TMExploreOn != 0 && win_id2win(t:TMExploreOn) != 0
		"echo 'split 4'
		"let g:netrw_browse_split=4
	"else
		"echo 'split 0'
		"let g:netrw_browse_split=0
	"endif
"endfun
"augroup TJMExploreBrowseSplitSet
	"autocmd!
	"autocmd WinEnter * call TMExploreBrowseSplitSet()
"augroup END


"==projects
" open project path in tjm proj path or elsewhere
" depends on TJM_PROJ_PATH environment variable to define base path
"-@ [ideas](https://vi.stackexchange.com/questions/39720/is-there-a-project-manager-extension-like-vscode-in-vim)
let g:currentProj = ''
fun! TMProjectComplete(proj, cmd, pos) abort
	let firstChar = a:proj[0]
	"--glob for relative or absolute paths
	if firstChar == '~' || firstChar == '/' || firstChar == '.'
		return glob(a:proj .. '*', 0, 1)
	else
		"--otherwise check in proj path
		if a:proj =~ '/'
			"--if subpath implied, glob in path
			let dirs = glob(expand($TJM_PROJ_PATH) .. '/' .. a:proj .. '*', 0, 1)
		else
			"--otherwise, just glob proj root
			let dirs = glob(expand($TJM_PROJ_PATH) .. '/*', 0, 1)
		endif
		"--format more nicely
		let ldirs = []
		for dir in dirs
			call add(ldirs, substitute(dir, $TJM_PROJ_PATH .. '/', '', ''))
		endfor
		"--filter to match passed value
		return filter(ldirs, 'v:val =~ a:proj')
	endif
endfun
fun! TMOpenProject(proj)
	let firstChar = a:proj[0]
	if firstChar == '~' || firstChar == '/' || firstChar == '.'
		let l:proj = a:proj
	else
		let l:proj = $TJM_PROJ_PATH .. '/' .. a:proj
	endif
	"--store old buffer for removal if "No Name"
	if !empty(a:proj)
		let g:currentProj = l:proj
	endif
	let loaded = 0
	"--restore project session if exists
	if !empty(a:proj) && filereadable(l:proj .. '/.projvimsess')
		let origSecure = &secure
		if !origSecure
			set secure
		endif
		"-! silent prevents error running `bwipe` stored in session, but also masks any other errors while loading
		execute 'silent! source ' .. l:proj .. '/.projvimsess'
		let loaded = 1
		if !origSecure
			set nosecure
		endif
		echow "loaded project from session"
	endif
	"--otherwise, cd and explore
	if !loaded
		let origBuffer = &ft != 'netrw' && expand('%') == '' && getline(1,'$') == [''] ? bufnr() : 0
		execute 'cd ' .. l:proj
		call TMExploreFn(l:proj)
		let loaded = 1
		"--remove "No Name" buffer
		if origBuffer && loaded
			execute 'bdelete ' .. origBuffer
		endif
	endif
endfun
command! -nargs=? -complete=customlist,TMProjectComplete Project call TMOpenProject('<args>')
"--save project session
fun! TMSaveProject()
	if !empty(g:currentProj)
		execute 'mksession! ' .. g:currentProj .. '/.projvimsess'
	endif
endfun
command! -nargs=0 ProjectSave call TMSaveProject()
"---storing options will override changes to this config, take up much more space
set sessionoptions-=options
"--clear project session
fun! TMClearProject()
	if !empty(g:currentProj)
		execute '!rm ' .. g:currentProj .. '/.projvimsess'
	endif
endfun
command! -nargs=0 ProjectClear call TMClearProject()

"=====
"==term
"=====
"--load shell aliases, etc for !
let $BASH_ENV = "~/.vim/bashenv"

"--support colors in gui terminal
"-@ https://superuser.com/a/449959
"-! has weird extra <return> press required in some cases
if has('patch-9.0.0100') && has('gui')
	set guioptions+=!
endif

"--no line numbers in term
augroup TJMTermNoNum
	autocmd!
	autocmd TerminalOpen term://* set nonu nornu
augroup END

"--switch term to normal mode
"-! only works when in insert mode, beeps if not
tnoremap <esc><esc> <C-\><C-n>

"--load new instance in existing instance when opening from terminal
"-# requires special call from terminal, see `o` command
"-@ https://www.reddit.com/r/vim/comments/tkcxhq/how_to_open_a_file_in_the_current_neovimvim_from/
fun! Tapi_OpenInTab(bufnum, arglist)
	echo "opening " . a:arglist[0]
	for fn in a:arglist
		execute 'tab drop ' . fn
	endfor
endfun


"--function to surround current text with parens, etc



fun! TMSurroundFn(strstart, strend = v:null, mode = v:null)
	if a:mode is v:null
		let a:mode = mode()
	endif
	if a:strstart == '(' && a:strend is v:null
		let a:strend = ")"
	endif
	if a:mode == 'v'
		let start = getpos("'<")
		let end = getpos("'>")
		"execute ':keeppatterns lockmarks s/\%V\_.*\%V/' .. a:strstart .. '&' .. a:strend .. '/'
		"call setpos(".", start)
		call setpos(".", [0,5,5,0])
		"call feedkeys("\<esc>i" .. a:strstart .. "\<esc>", 'n')
		"call setpos(".", end)
		"call feedkeys('i' .. a:strend .. "\<esc>", 'n')
		"if col(".") == col("$") - 1
			"call feedkeys('i', 'n')
		"else
			"call feedkeys('li', 'n')
		"endif
	""--attempt to handle no selection
	else
		call feedkeys('i' .. (col(".") == col("$") - 1 ? '<right>' : '') .. a:strstart .. a:strend .. "\<esc>i", 'n')
	endif
endfun
"command! -nargs=+ -range TMSurround call TMSurroundFn(<args>)
"noremap <expr> <leader>( TMSurroundFn('(', ')')
"vnoremap <expr> <leader>( TMSurroundFn('(', ')', "v")
"(V=`git describe --tags --abbrev=0`)
